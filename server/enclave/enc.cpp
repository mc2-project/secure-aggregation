// Copyright (c) Open Enclave SDK contributors.
// Licensed under the MIT License.

#include <stdio.h>
#include <vector>
#include <numeric>

// Include the trusted modelaggregator header that is generated
// during the build. This file is generated by calling the
// sdk tool oeedger8r against the modelaggregator.edl file.
#include "modelaggregator_t.h"

using namespace std; 
// This is the function that the host calls. It performs
// the aggregation and encrypts the new model to pass back
void enclave_modelaggregator(char** encrypted_accumulator, size_t length, char* encrypted_old_params, char** encrypted_new_params_ptr)
{
    char* serialized_old_params = encrypted_old_params; // TODO: wrap with David's code
    map<string, vector<double>> params = serialized_old_params; // TODO: wrap with David's code

    
    vector<map<string, vector<double>>> accumulator;
    set<string> vars_to_aggregate;

    for (int i = 0; i < length; i++) {
        char* serialized_params = encrypted_accumulator[i]; //TODO: wrap with David's code
        map<string, vector<double>> params = serialized_params; //TODO: wrap with David's code

        for (const auto& pair : params) {
            vars_to_aggregate.insert(pair.first);
        }

        accumulator.push_back(params);
    }

    for (string v_name : vars_to_aggregate) {
        n_local_iters = vector<double>;
        vars = vector<vector<double>>;

        for (map<string, vector<double>> acc_params : accumulator) {
            if (acc_params.find(v_name) == acc_params.end()) { // these params don't have the variable from client
                continue;
            }

            // Each params map will have an additional key "_contribution" to hold the number of local iterations
            double& n_iter = acc_params["_contribution"];
            n_local_iters.push_back(n_iter);

            // Weighted using local iterations
            vector<double>& weights = acc_params[v_name];
            for_each(weights.begin(), weights.end(), [](double& d) { d *= n_iter; });
            vars.push_back(weights);
        }

        if (n_local_iters.empty()) {
            continue; // Didn't receive this variable from any clients
        }

        vector<double> new_val(vars.size(), 0.0);
        double iters_sum = accumulator(n_local_iters.begin(), n_local_iters.end(); 0);
        for (int i = 0; i < new_val.size(); i++) {
            for (vector<double> weights : vars) {
                new_val[i] += weights[i];
            }
            new_val[i] /= iters_sum;
        }
        params[v_name] = new_val;
    }

    char* serialized_new_params = params; // TODO: wrap with David's code
    char* encrypted_new_params = serialized_new_params; // TODO: wrap with David's code

    long encrypted_length = strlen(encrypted_new_params);

    unsigned char* usr_addr_parms = (unsigned char*) oe_host_malloc(encrypted_length + 1);
    memcpy(usr_addr_parms, encrypted_new_params, encrypted_length + 1);
    *encrypted_new_params_ptr = usr_addr_params;

    // Memory cleanup
    free(encrypted);
}
